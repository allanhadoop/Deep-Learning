# source - Python Numpy module -- source http://cs231n.github.io/python-numpy-tutorial/
Numpy is the core library for scientific computing in Python. It provides a high-performance 
multidimensional array object, and tools for working with these arrays.
# A numpy array is a grid of values, all of the same type, and is indexed by a tuple of nonnegative integers. 
The number of dimensions is the rank of the array; the shape of an array is a tuple of integers giving the size 
of the array along each dimension.
------------------------------------------------------------------------------------------------------------
We can initialize numpy arrays from nested Python lists, and access elements using square brackets:
here within bracket it is column


import numpy as np
a = np.array([1,3,5])
print(a.shape)
print(a[0],a[1],a[2])
print("---------------")
b = np.array( [  [3,5,2],[6,8,23] ] )       #see outer bracket for syntax
print(b.shape)
print(b[0,2],b[0,1],b[1,0],b[1,2])       # here d is read as first digit is - two columns(0,1 index) and second digit is 3 rows within column(0,1,2 index) e.g. [0,2]
Output -- 
(3,)
(1, 3, 5)
---------------
(2, 3)
(2, 5, 6, 23)
------------------------------------------------------------------------------------------------------------
# Numpy also provides many functions to create arrays:
import numpy as np
a = np.zeros((2, 2))  # Create an array of all zeros
print a

b = np.ones((2, 2))  # Create an array of all ones
print b

c = np.full((2, 2), 100)  # Create a constant array
print c

d = np.eye(2)  # Create a 2x2 identity matrix
print d

e = np.random.random((2, 2))  # Create an array filled with random values
print e
Output --
[[ 0.  0.]
 [ 0.  0.]]
 
[[ 1.  1.]
 [ 1.  1.]]
 
[[ 100.  100.]
 [ 100.  100.]]

[[ 1.  0.]
 [ 0.  1.]]

[[ 0.53194896  0.88849381]
 [ 0.9743469   0.40803588]]
------------------------------------------------------------------------------------------------------------
# Array Indexing -- Numpy offers several ways to index into arrays.
Similar to Python lists, numpy arrays can be sliced. Since arrays may be multidimensional, 
you must specify a slice for each dimension of the array:
import numpy as np

# Create the following rank 2 array with shape (3, 4)
# [[ 1  2  3  4]
#  [ 5  6  7  8]
#  [ 9 10 11 12]]
a = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])

# Use slicing to pull out the subarray consisting of the first 2 rows
# and columns 1 and 2; b is the following array of shape (2, 2):
# [[2 3]
#  [6 7]]
b = a[0:2, 1:3]     #0:2 is first 2 rows and 1:3 is within those 2 rows (it prints upto 1 , doesnot go to 2 index), 1 till 3rd column (it prints upto 2 index, not 3) . O is first column
print(b)

# A slice of an array is a view into the same data, so modifying it will modify the original array.
print a[0, 1]   # Prints "2"

b[0, 0] = 77    # b[0, 0] is the same piece of data as a[0, 1]
print a[0, 1]   # Prints "77"
print(a)
Output -- ------
[[2 3]
 [6 7]]
2
77
[[ 1 77  3  4]
 [ 5  6  7  8]
 [ 9 10 11 12]]
------------------------------------------------------------------------------------------------------------
a = np.array([[3,2,3,5,6],[4,2,3,5,7],[5,5,3,2,4]])
print(a)

b = a[1:3,1:4]      #1:3 means from second and third rows and 1:4 means from 1 till 3 to be printed columns within those 2 rows.
print(b)

b[1,1] = 88
print(a)
Output ------- 
[[3 2 3 5 6]
 [4 2 3 5 7]
 [5 5 3 2 4]]
[[2 3 5]
 [5 3 2]]
[[ 3  2  3  5  6]
 [ 4  2  3  5  7]
 [ 5  5 88  2  4]]
------------------------------------------------------------------------------------------------------------
# Mixing integer indexing with slice indexing. However, doing so will yield an array of lower rank than the 
original array. Note that this is quite different from the way that MATLAB handles array slicing

import numpy as np

# Create the following rank 2 array with shape (3, 4)
# [[ 1  2  3  4]
#  [ 5  6  7  8]
#  [ 9 10 11 12]]
a = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])

# Two ways of accessing the data in the middle row of the array.
# Mixing integer indexing with slices yields an array of lower rank,
# while using only slices yields an array of the same rank as the
# original array:
row_r1 = a[1, :]    # Rank 1 view of the second row of a     --> SEE the syntax of slice index  [ : , : ]  
row_r2 = a[1:2, :]  # Rank 2 view of the second row of a     --> SEE the syntax of slice index  [ : , : ]  
print row_r1, row_r1.shape  # Prints "[5 6 7 8] (4,)"
print row_r2, row_r2.shape  # Prints "[[5 6 7 8]] (1, 4)"

# We can make the same distinction when accessing columns of an array:
col_r1 = a[:, 1]
col_r2 = a[:, 1:2]
print col_r1, col_r1.shape  # Prints "[ 2  6 10] (3,)"
print col_r2, col_r2.shape  # Prints "[[ 2]
                            #          [ 6]
                            #          [10]] (3, 1)"
col_r2[2] = 99
print(a)
Output --------
[5 6 7 8] (4,)
[[5 6 7 8]] (1, 4)
[ 2  6 10] (3,)
[[ 2]
 [ 6]
 [10]] (3, 1)
 [[ 1  2  3  4]
 [ 5  6  7  8]
 [ 9 99 11 12]]
------------------------------------------------------------------------------------------------------------
# Integer array indexing -- When you index into numpy arrays using slicing, the resulting array view will 
always be a subarray of the original array.  In contrast, integer array indexing allows you to construct 
arbitrary arrays using the data from another array.

import numpy as np

a = np.array([[1,2], [3, 4], [5, 6]])
print(a)
print("----------")
print(a.shape)
print("----------")
# An example of integer array indexing.
# The returned array will have shape (3,) and
print a[[1, 2, 0], [0, 1, 1]]                      --> SEE the syntax of integer index [ [ ...] ] 
# [[ 1 , 2 , 0 ]] means array is indexed using 1st row then 2nd and then 0th
# [[ 0, 1 ,1 ]] means we get further indexing of the respective columns.e.g. 1st row will get 0 index number (which is 3
# then 2nd row will get 1st index digit which is 6 and 0th row will get 1st index digit which is 2

# The above example of integer array indexing is equivalent to this:
# print np.array([a[0, 0], a[1, 1], a[2, 0]])  # Prints "[1 4 5]"

# When using integer array indexing, you can reuse the same
# element from the source array:
print a[[1, 2], [1, 1]]                     --> SEE the syntax of integer index [ [ ...] ] 

OUTPUT -- 
[[1 2]
 [3 4]
 [5 6]]
----------
(3, 2)
----------
[3 6 2]
[4 6]
------------------------------------------------------------------------------------------------------------
# One useful trick with integer array indexing is selecting or mutating one element from each row of a matrix:
import numpy as np

# Create a new array from which we will select elements
a = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])

print a  # prints "array([[ 1,  2,  3],
         #                [ 4,  5,  6],
         #                [ 7,  8,  9],
         #                [10, 11, 12]])"

# Create an array of indices
b = np.array([0, 2, 0, 1])

# Select one element from each row of a using the indices in b
print a[np.arange(4), b]  # Prints "[ 1  6  7 11]"              -->>SEE Syntax [ np.arrange(x), b ]

# Mutate one element from each row of a using the indices in b
a[np.arange(4), b] += 10

print a  # prints "array([[11,  2,  3],
         #                [ 4,  5, 16],
         #                [17,  8,  9],
         #                [10, 21, 12]])
------------------------------------------------------------------------------------------------------------







